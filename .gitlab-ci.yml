default:
  image: docker:latest

stages:
  - build
  - deploy_test
  - test
  - deploy_uat

.ssh_credentials: &ssh_credentials
  before_script: 
    - mkdir -p ~/.ssh
    # we have to store SSH key in base 64 encoding to be able to mask the variable
    - echo -e "$SSH_PRIVATE_KEY1"| base64 -d > ~/.ssh/id_rsa
    # Sets the permission to 600 to prevent a problem with AWS
    - chmod 600  ~/.ssh/id_rsa
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'  


Build_and_Push:
# need to use a (dind: Docker IN Docker) service to build image inide a container
  services:
  - docker:dind
  stage: build
# only run the build job if the app or dockerfile change  
  only:
    changes:
      - Dockerfile
      - app/*
  tags:
    - docker
  before_script:
  - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  #- docker info
  script: 
    # inject job name:
    - sed -i "s/<\/bo/<br>deployed by $CI_JOB_NAME $CI_COMMIT_SHA <\/bo/g" app/app.js
    - docker build --pull --tag $CI_REGISTRY_IMAGE:latest --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - echo "tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
#    - docker run $CI_REGISTRY_IMAGE /script/to/run/tests
#    - docker tag $CI_REGISTRY_IMAGE $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    
Spin_Test_Environment:
  # no way to pass variables between jobs in gitlab, will use cache for that
  cache:
   key: test-vars
   paths:
    - my_vars.sh  
  stage: deploy_test
#  when: manual
  image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest
  script:
    - >
      aws ec2 run-instances --image-id ami-0ded330691a314693 --count 1
      --instance-type t2.micro --key-name myec22
      --security-group-ids sg-01f96ce6a38acab33 --subnet-id subnet-752fd313
      --placement "{\"AvailabilityZone\": \"ap-southeast-2b\",\"Tenancy\": \"default\"}"
      --instance-initiated-shutdown-behavior terminate
      --user-data file://deploy/test_ec2.sh > ec2_deploy_output.json
    - EC2_ID=`grep -Po 'InstanceId":\s"\K([^"]*)' ec2_deploy_output.json` && echo $EC2_ID
#    - EC2_ID=i-04888cb189e29f3b0
    ## wait till public IP is assigned
    - sleep 20
    - EC2_IP=`aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" "Name=instance-id,Values=$EC2_ID" --query 'Reservations[*].Instances[*].[PublicIpAddress]' --output text`
    - echo "EC2_IP=$EC2_IP" > my_vars.sh
    - echo "app will be deployed to $EC2_IP:8888"
    - cat my_vars.sh

Deploy_and_Test:
  <<: *ssh_credentials
  image: node:14.8.0-alpine3.10
  cache:
    key: test-vars
    paths:
     - my_vars.sh  
  stage: test
#  when: manual
  script:
  - apk add openssh-client
  - apk add curl
  - cat my_vars.sh
  - source my_vars.sh
#  - printenv | grep EC2 
  - echo $EC2_IP
## wait for docker daemon to start
  - sleep 30
  - ssh ec2-user@$EC2_IP "sudo docker run -d -p 8888:3000 --name my_app $CI_REGISTRY_IMAGE"
  - echo "app is running at http://$EC2_IP:8888"
## run the tests!  
  - echo "http://$EC2_IP:8888"
  - curl "http://$EC2_IP:8888"
    
Deploy to UAT:
  <<: *ssh_credentials  
  stage: deploy_uat
  only:
    - master
    - manual
#    - schedules
  when: on_success
  tags:
    - docker
  script: 
    - ls -la 
    - >
      ssh ec2-user@$STAGING_SERVER "
      sudo docker stop my_app;
      sudo docker rm my_app;
      sudo docker pull  $CI_REGISTRY_IMAGE"
    - ssh ec2-user@$STAGING_SERVER "sudo docker run -d -p 8888:3000 --name my_app $CI_REGISTRY_IMAGE"
      

.Deploy to VM:
  artifacts:
    paths:
      - ./
  stage: deploy
  only:
    - manual
  tags:
    - docker
  before_script:
    <<: *ssh_credentials   
  script: 
    - ls -la
    # inject job name:
    - sed -i "s/<\/bo/<br>deployd by $CI_JOB_NAME<\/bo/g" app/app.js
    - ssh ec2-user@$STAGING_SERVER "mkdir staging/_tmp && ls -la"
    - scp -r ./app/* ec2-user@$STAGING_SERVER:staging/_tmp
    - ssh ec2-user@$STAGING_SERVER "mv staging/live staging/_old && mv staging/_tmp staging/live"
    - ssh ec2-user@$STAGING_SERVER "rm -rf staging/_old  && cd staging/live && npm install && npm start"
  environment:     
    name: staging     
    # Exposes a button that when clicked take you to the defined URL:
    url: http://$STAGING_SERVER:8080/ 

.deploy_prod:
  stage: deploy
  script:
    - echo "Deploy to production server"
    - export
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - master

include:
  - template: Dependency-Scanning.gitlab-ci.yml
  - template: Security/License-Scanning.gitlab-ci.yml
