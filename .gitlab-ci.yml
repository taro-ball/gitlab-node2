default:
  image: docker:latest

variables:
  APP_NAME: "my_app"
  APP_PORT: "8888"

stages:
  - lint
  - build
  - deploy_test
  - test
  - deploy_uat

.ssh_credentials: &ssh_credentials
  before_script: 
    - mkdir -p ~/.ssh
    # we have to store SSH key in base 64 encoding to be able to mask the variable
    - echo -e "$SSH_PRIVATE_KEY1"| base64 -d > ~/.ssh/id_rsa
    # Sets the permission to 600 to prevent a problem with AWS
    - chmod 600  ~/.ssh/id_rsa
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'  

ES_Lint:
  stage: lint
  image: node:14.8.0-alpine
  only:
    changes:
      - app/*  
  cache: 
    key: $CI_COMMIT_REF_SLUG-$CI_PROJECT_DIR
    paths:
      - app/node_modules/  
  script:
    - cd app
    - npm ci
    - npx eslint --format gitlab .
    - pwd; cd; pwd
    - cat gl-codequality.json
  artifacts:
    reports:
      codequality: gl-codequality.json

Build_and_Push:
# need to use a (dind: Docker IN Docker) service to build image inide a container
  artifacts:
    when: always
    paths:
      - ./build_success
  services:
  - docker:dind
  stage: build
# only run the build job if the app or dockerfile change  
  only:
    changes:
      - Dockerfile
      - app/*
  tags:
    - docker
  before_script:
  - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  #- docker info
  script: 
    # inject job name:
    - sed -i "s/<\/bo/<br>deployed by $CI_JOB_NAME $CI_COMMIT_SHA <\/bo/g" app/app.js
    - docker build --pull --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA . > build_success
    - cat build_success
#    - docker run $CI_REGISTRY_IMAGE /script/to/run/tests
#    - docker tag $CI_REGISTRY_IMAGE $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - > 
      if [ "$CI_COMMIT_BRANCH" == "master" ]; then
          echo -e "Master branch, tagging with 'latest'\n==========\n";
          docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest;
          docker push $CI_REGISTRY_IMAGE:latest
      else
          echo -e "Not a master branch ($CI_COMMIT_BRANCH), only tagging with commit SHA\n==========\n"
      fi
  
Spin_Test_Environment:
  # no way to pass variables between jobs in gitlab, will use cache for that
  cache:
   key: test-vars
   paths:
    - my_vars.sh  
  stage: deploy_test
#  when: manual
  image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest
  script:
    - >
      aws ec2 run-instances --image-id ami-0ded330691a314693 --count 1
      --instance-type t2.micro --key-name myec22
      --security-group-ids sg-01f96ce6a38acab33 --subnet-id subnet-752fd313
      --placement "{\"AvailabilityZone\": \"ap-southeast-2b\",\"Tenancy\": \"default\"}"
      --instance-initiated-shutdown-behavior terminate
      --user-data file://deploy/test_ec2.sh > ec2_deploy_output.json
    - EC2_ID=`grep -Po 'InstanceId":\s"\K([^"]*)' ec2_deploy_output.json` && echo $EC2_ID
#    - EC2_ID=i-04888cb189e29f3b0
    ## wait till public IP is assigned
    - EC2_IP=""
    - while [ -z "$EC2_IP" ]; do EC2_IP=`aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" "Name=instance-id,Values=$EC2_ID" --query 'Reservations[*].Instances[*].[PublicIpAddress]' --output text` ;echo `date` $EC2_IP ; sleep 2; done;
#    - EC2_IP=`aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" "Name=instance-id,Values=$EC2_ID" --query 'Reservations[*].Instances[*].[PublicIpAddress]' --output text`
    - echo "EC2_IP=$EC2_IP" > my_vars.sh
    - echo "app will be deployed to $EC2_IP:$APP_PORT"
    - cat my_vars.sh
    - ls -la

Integration_Testing:
  <<: *ssh_credentials
  artifacts:
    when: always
    paths:
      - ./newman/*.html
  image: 
    name: postman/newman:5.1.2-alpine
    entrypoint: [""]
  cache:
    key: test-vars
    paths:
     - my_vars.sh  
  stage: test
#  when: manual
  script:
  - apk add openssh-client
  - apk add grep
  # - apk add curl
  - cat my_vars.sh
  - source my_vars.sh
#  - printenv | grep EC2 
  - echo $EC2_IP
## wait for docker daemon to start
  - docker_status=""
  - while [ -z "$docker_status" ]; do docker_status=`ssh ec2-user@$EC2_IP "( sudo service docker status || true ) | grep running || true"` ;echo `date` $docker_status; sleep 2; done;
## deploy app to TEST $CI_COMMIT_SHA  2>&1 | grep "not found"
  - > 
    if [ -f "build_success" ]; then
        echo -e "We have a build, lets deploy it\n==========\n";
        ssh ec2-user@$EC2_IP "sudo docker run -d -p $APP_PORT:3000 --name $APP_NAME $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA 2>&1";
    else
        echo -e "No build, deploying :latest\n==========\n";
        ssh ec2-user@$EC2_IP "sudo docker run -d -p $APP_PORT:3000 --name $APP_NAME $CI_REGISTRY_IMAGE:latest"
    fi
  - echo -e "app is running at http://$EC2_IP:$APP_PORT\n==========\n"
## run the tests!
  #- npm install -g newman
  - npm install -g newman-reporter-htmlextra
  - newman run --global-var "test-env-base-url=http://$EC2_IP:$APP_PORT" integration-test/postman_test1.json -r htmlextra,cli
  - ls -la; ls -la integration-test
  - echo -e "test successful against http://$EC2_IP:$APP_PORT\n==========\n"
  # check container logs
  - ssh ec2-user@$EC2_IP "sudo docker log $APP_NAME" || true
  #- curl "http://$EC2_IP:$APP_PORT"
    
Deploy to UAT:
  <<: *ssh_credentials  
  stage: deploy_uat
  only:
    - master
#    - schedules
  when: manual
  script: 
    - ls -la 
    # delete the running container & pull the latest image
    - >
      ssh ec2-user@$STAGING_SERVER "
      sudo docker stop my_app;
      sudo docker rm my_app;
      sudo docker pull  $CI_REGISTRY_IMAGE"
    - ssh ec2-user@$STAGING_SERVER "sudo docker run -d -p $APP_PORT:3000 --name my_app $CI_REGISTRY_IMAGE"
      

.Deploy to VM:
  artifacts:
    paths:
      - ./
  stage: deploy
  only:
    - manual
  tags:
    - docker
  before_script:
    <<: *ssh_credentials   
  script: 
    - ls -la
    # inject job name:
    - sed -i "s/<\/bo/<br>deployd by $CI_JOB_NAME<\/bo/g" app/app.js
    - ssh ec2-user@$STAGING_SERVER "mkdir staging/_tmp && ls -la"
    - scp -r ./app/* ec2-user@$STAGING_SERVER:staging/_tmp
    - ssh ec2-user@$STAGING_SERVER "mv staging/live staging/_old && mv staging/_tmp staging/live"
    - ssh ec2-user@$STAGING_SERVER "rm -rf staging/_old  && cd staging/live && npm install && npm start"
  environment:     
    name: staging     
    # Exposes a button that when clicked take you to the defined URL:
    url: http://$STAGING_SERVER:8080/ 

.deploy_prod:
  stage: deploy
  script:
    - echo "Deploy to production server"
    - export
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - master

# include:
#  - template: Code-Quality.gitlab-ci.yml
#  - template: Dependency-Scanning.gitlab-ci.yml
#  - template: Security/License-Scanning.gitlab-ci.yml
